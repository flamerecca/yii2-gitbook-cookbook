# 單一表格繼承（Single table inheritance） {#single-table-inheritance}

大部分資料庫沒有處理繼承問題，所以網頁設計需要的時候，就必須要自己製作。其中一個方法是[single table inheritance](http://martinfowler.com/eaaCatalog/singleTableInheritance.html)，Martin Fowler介紹得很完整。

根據這個模式，我們會在表格裡面加上`type`欄位，用來決定該資料屬於哪一個類別（class）的物件。

以下我們實做一個簡單的繼承類別結構：

```markdown
Car
|- SportCar
|- HeavyCar
```

## 準備 {#get-ready}

這邊我們使用基本的 Yii 設置。資料庫建立好了之後，執行以下SQL指令來建立表格以及放入資料：

```sql
CREATE TABLE `car` (
    `id` int NOT NULL AUTO_INCREMENT,
    `name` varchar(255) NOT NULL,
    `type` varchar(255) DEFAULT NULL,
    PRIMARY KEY (`id`)
);

INSERT INTO car (id, NAME, TYPE) VALUES (1, 'Kamaz', 'heavy'), (2, 'Ferrari', 'sport'), (3, 'BMW', 'city');
```

然後使用 Gii 工具，生成`Car`模型。

## 實做物件繼承 {#how-to-do-it}

We'll need a quite simple custom query class in order to always apply car type to query condition. Create`models/CarQuery.php`:

```php
namespace app\models;

use yii\db\ActiveQuery;

class CarQuery extends ActiveQuery
{
    public $type;
    public $tableName;

    public function prepare($builder)
    {
        if ($this->type !== null) {
            $this->andWhere(["$this->tableName.type" => $this->type]);
        }
        return parent::prepare($builder);
    }
}
```

Now let's create models for car classes for different types. First`models/SportCar.php`:

```php
namespace app\models;

class SportCar extends Car
{
    const TYPE = 'sport';

    public function init()
    {
        $this->type = self::TYPE;
        parent::init();
    }

    public static function find()
    {
        return new CarQuery(get_called_class(), ['type' => self::TYPE, 'tableName' => self::tableName()]);
    }

    public function beforeSave($insert)
    {
        $this->type = self::TYPE;
        return parent::beforeSave($insert);
    }
}
```

Then`models/HeavyCar.php`:

```php
namespace app\models;

class HeavyCar extends Car
{
    const TYPE = 'heavy';

    public function init()
    {
        $this->type = self::TYPE;
        parent::init();
    }

    public static function find()
    {
        return new CarQuery(get_called_class(), ['type' => self::TYPE, 'tableName' => self::tableName()]);
    }

    public function beforeSave($insert)
    {
        $this->type = self::TYPE;
        return parent::beforeSave($insert);
    }
}
```

Now we need to override`instantiate`method in the`Car`model:

```php
public static function instantiate($row)
{
    switch ($row['type']) {
        case SportCar::TYPE:
            return new SportCar();
        case HeavyCar::TYPE:
            return new HeavyCar();
        default:
           return new self;
    }
}
```

Also we need to override`tableName`method in the`Car`model in order for all models involved to use a single table:

```php
public static function tableName()
{
    return '{{%car%}}';
}
```

That's it. Let's try it. Create the following`actionTest`in`SiteController`and run it:

```php
// finding all cars we have
$cars = Car::find()->all();
foreach ($cars as $car) {
    echo "$car->id $car->name " . get_class($car) . "<br />";
}

// finding any sport car
$sportCar = SportCar::find()->limit(1)->one();
echo "$sportCar->id $sportCar->name " . get_class($sportCar) . "<br />";
```

輸出會是：

```
1 Kamaz app\models\HeavyCar
2 Ferrari app\models\SportCar
3 BMW app\models\Car
2 Ferrari app\models\SportCar
```

可以看到，物件成功的根據`type`欄位建立，搜尋功能也如同我們所希望的一樣正常運作。

## 運作原理 {#how-it-works}

`SportCar`和`HeavyCar`模型很相近。兩個均繼承`Car`模型， 覆蓋（override）兩個函式。In`find`method we're instantiating a custom query class that stores car type and applies it in the`prepare`method that is called right before forming SQL for the database query.`SportCar`will only search for sport cars and`HeavyCar`will only search for heavy cars. In`beforeSave`we're making sure that the proper`type`is written to database when class is saved.`TYPE`constants are introduced just for convenience.

The`Car`model is pretty much what was generated by Gii except additional`instantiate`method. This method is called after data is retrieved from database and is about to be used to initialize class properties. Return value is uninitialized class instance and the only argument passed to the method is the row of data retrieved from the database. Exactly what we need. The implementation is a simple switch statement where we're checking if the`type`field matches type of the classes we suport. If so, an instance of the class is returned. If nothing matches, it falls back to returning a`Car`model instance.

## 處理唯一（unique）值 {#handling-unique-values}

如果有欄位被標記為唯一（unique），為了避免`UniqueValidator`出錯，需要標記 `targetClass`。

```php
public function rules()
{
    return [
        [['MyUniqueColumnName'], 'unique', 'targetClass' => '\app\models\Car'],
    ];
}
```



